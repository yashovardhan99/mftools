{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NiveshPy","text":"<p>NiveshPy is a financial library designed for managing mutual funds and investment portfolios. It provides functionalities to fetch fund prices, manage portfolios, and calculate performance.</p> <p>For more information, check out our Getting Started page.</p> <p>NiveshPy is targeted towards Indian  markets, but the API is built in a way that any financial data can be added as a source. See our guide on Plugins for more information.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To get started, install NiveshPy from PyPi:</p> <pre><code>pip install niveshpy\n</code></pre> <p>After installing, you can simply start using NiveshPy:</p> <pre><code>from niveshpy import Nivesh\n\napp = Nivesh()\n\napp.get_quotes(...)\n</code></pre>"},{"location":"#work-in-progress","title":"Work in progress","text":"<p>This project is a work in progress. The public API is still in development and unstable.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for more details.</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2025 Yashovardhan Dhanania</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>New Github workflow for automated testing and coverage.</li> <li>New classifiers to properly describe the project</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Problem with publishing assets to Github Releases</li> <li>Documentation URL fixes</li> </ul>"},{"location":"changelog/#010dev0","title":"0.1.0.dev0","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Basic project structure for Python package.</li> <li>Ability to fetch and store latest and historical quotes.</li> <li>Pre-built plugin: amfi (Mutual Fund)</li> <li>Documentation</li> </ul> <p>To view the latest version of this file, go to CHANGELOG.md</p>"},{"location":"guide/","title":"Getting Started","text":""},{"location":"guide/#installation","title":"Installation","text":""},{"location":"guide/#with-pip","title":"With pip","text":"<p>To get started, install NiveshPy from PyPi:</p> <pre><code>pip install niveshpy\n</code></pre>"},{"location":"guide/#with-git","title":"With git","text":"<p>You can also download the app from GitHub and build it on your own.</p> <p>First, clone the repository:</p> <pre><code>git clone https://github.com/yashovardhan99/niveshpy.git\n</code></pre> <p>Next, install the package and all it's dependencies with: <pre><code>pip install -e niveshpy\n</code></pre></p>"},{"location":"guide/#quick-start","title":"Quick Start","text":"<p>After installing, you can simply start using NiveshPy:</p> <pre><code>from niveshpy import Nivesh\n\napp = Nivesh()\n\napp.get_quotes(...)\n</code></pre> <p>Currently, the following functions are supported:</p> <ul> <li><code>app.get_quotes()</code> to get the current/historical prices of your instruments.</li> <li><code>app.get_tickers()</code> to get a list of all available tickers.</li> <li><code>app.get_sources()</code> to check all configured sources.</li> </ul>"},{"location":"guide/#plugins","title":"Plugins","text":"<p>NiveshPy ships with some pre-built plugins to make your life easier.</p> <p>To learn more about these plugins, check out our Plugins page</p>"},{"location":"plugins/","title":"Plugins","text":"<p>NiveshPy uses a plugin-based system.</p>"},{"location":"plugins/#pre-built-plugins","title":"Pre-Built plugins","text":"<p>The following plugins are pre-built:</p> <ul> <li>AMFI</li> </ul>"},{"location":"plugins/amfi/","title":"Plugin: AMFI","text":"<p>AMFI is a built-in NiveshPy plugin that can be used to get data Mutual Fund data from Association of Mutual Funds in India (AMFI).</p> <p>AMFI will be able to fetch all available mutual funds along with their daily prices.</p>"},{"location":"plugins/amfi/#usage","title":"Usage","text":"<p>As AMFI is a built-in plugin, no additional steps are needed to start using it.</p> <p>Simply use the <code>source_key</code> \"amfi\" when querying data to start using it.</p> <p>AMFI uses the mutual fund scheme codes as ticker symbol.</p>"},{"location":"reference/models/","title":"Models","text":"<p>Models for NiveshPy.</p>"},{"location":"reference/models/#niveshpy.models.OHLC","title":"<code>OHLC</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Class to hold OHLC data.</p>"},{"location":"reference/models/#niveshpy.models.OHLC.get_polars_schema","title":"<code>get_polars_schema()</code>  <code>classmethod</code>","text":"<p>Get the Polars schema for the OHLC class.</p> Source code in <code>niveshpy/models/base.py</code> <pre><code>@classmethod\ndef get_polars_schema(cls) -&gt; pl.Schema:\n    \"\"\"Get the Polars schema for the OHLC class.\"\"\"\n    return pl.Schema(\n        {\n            \"symbol\": pl.String(),\n            \"date\": pl.Date(),\n            \"open\": pl.Decimal(scale=4),\n            \"high\": pl.Decimal(scale=4),\n            \"low\": pl.Decimal(scale=4),\n            \"close\": pl.Decimal(scale=4),\n        }\n    )\n</code></pre>"},{"location":"reference/models/#niveshpy.models.Plugin","title":"<code>Plugin()</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all plugins.</p> <p>Initialize the plugin.</p> Source code in <code>niveshpy/models/plugins.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the plugin.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/models/#niveshpy.models.Plugin.get_info","title":"<code>get_info()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Return plugin information.</p> Source code in <code>niveshpy/models/plugins.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef get_info(cls) -&gt; PluginInfo:\n    \"\"\"Return plugin information.\"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/models/#niveshpy.models.Plugin.get_sources","title":"<code>get_sources()</code>  <code>abstractmethod</code>","text":"<p>Return a list of sources for the plugin.</p> Source code in <code>niveshpy/models/plugins.py</code> <pre><code>@abc.abstractmethod\ndef get_sources(self) -&gt; Iterable[Source]:\n    \"\"\"Return a list of sources for the plugin.\"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/models/#niveshpy.models.PluginInfo","title":"<code>PluginInfo(name, description, version, author, author_email)</code>","text":"<p>Class to hold plugin information.</p> <p>Initialize the plugin info.</p> Source code in <code>niveshpy/models/plugins.py</code> <pre><code>def __init__(self, name, description, version, author, author_email):\n    \"\"\"Initialize the plugin info.\"\"\"\n    self.name = name\n    self.description = description\n    self.version = version\n    self.author = author\n    self.author_email = author_email\n</code></pre>"},{"location":"reference/models/#niveshpy.models.PluginInfo.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the plugin info.</p> Source code in <code>niveshpy/models/plugins.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return a string representation of the plugin info.\"\"\"\n    return f'PluginInfo(name=\"{self.name}\", description=\"{self.description}\", version=\"{self.version}\", author=\"{self.author}\", author_email=\"{self.author_email}\")'\n</code></pre>"},{"location":"reference/models/#niveshpy.models.Quote","title":"<code>Quote</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Class to hold price data.</p>"},{"location":"reference/models/#niveshpy.models.Quote.get_polars_schema","title":"<code>get_polars_schema()</code>  <code>classmethod</code>","text":"<p>Get the Polars schema for the Quote class.</p> Source code in <code>niveshpy/models/base.py</code> <pre><code>@classmethod\ndef get_polars_schema(cls) -&gt; pl.Schema:\n    \"\"\"Get the Polars schema for the Quote class.\"\"\"\n    return pl.Schema(\n        {\n            \"symbol\": pl.String(),\n            \"date\": pl.Date(),\n            \"price\": pl.Decimal(scale=4),\n        }\n    )\n</code></pre>"},{"location":"reference/models/#niveshpy.models.ReturnFormat","title":"<code>ReturnFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for return formats.</p> <p>This enum defines the different formats in which data can be returned.</p> <p>Attributes:</p> Name Type Description <code>DICT</code> <p>Format as a dictionary mapping column names as keys.</p> <code>PL_DATAFRAME</code> <p>Format as a Polars DataFrame.</p> <code>PL_LAZYFRAME</code> <p>Format as a Polars LazyFrame. This is the internal format used by niveshpy.</p> <code>PD_DATAFRAME</code> <p>Format as a Pandas DataFrame.</p> <code>JSON</code> <p>Format as a JSON string.</p> <code>CSV</code> <p>Format as a CSV string.</p>"},{"location":"reference/models/#niveshpy.models.Source","title":"<code>Source()</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all data sources.</p> <p>Initialize the source.</p> Source code in <code>niveshpy/models/sources.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the source.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/models/#niveshpy.models.Source.get_quotes","title":"<code>get_quotes(*tickers, start_date=None, end_date=None)</code>  <code>abstractmethod</code>","text":"<p>Get the quotes for the given tickers.</p> <p>Parameters:</p> Name Type Description Default <code>*tickers</code> <code>str</code> <p>The list of tickers to get quotes for. If empty, all tickers will be fetched.</p> <code>()</code> <code>start_date</code> <code>Optional[date]</code> <p>The start date for the quotes. If none, the source should return the latest data.</p> <code>None</code> <code>end_date</code> <code>Optional[date]</code> <p>The end date for the quotes. If none, the source should return the latest data.</p> <code>None</code> Note <ul> <li>If both start_date and end_date are None, the source should return the latest data.</li> <li>If only one date is provided, the source should return data for that date.</li> <li>Date range would never exceed the <code>data_group_period</code> specified in the source config.</li> </ul> <p>Returns:</p> Type Description <code>QuotesIterable</code> <p>An iterable of Quote or OHLC objects or a Polars DataFrame or a Pandas DataFrame.</p> Source code in <code>niveshpy/models/sources.py</code> <pre><code>@abc.abstractmethod\ndef get_quotes(\n    self,\n    *tickers: str,\n    start_date: date | None = None,\n    end_date: date | None = None,\n) -&gt; QuotesIterable:\n    \"\"\"Get the quotes for the given tickers.\n\n    Args:\n        *tickers (str): The list of tickers to get quotes for. If empty, all tickers will be fetched.\n        start_date (Optional[date]): The start date for the quotes. If none, the source should return the latest data.\n        end_date (Optional[date]): The end date for the quotes. If none, the source should return the latest data.\n\n        This property should be ignored if the source uses the ALL_TICKERS strategy.\n\n    Note:\n        - If both start_date and end_date are None, the source should return the latest data.\n        - If only one date is provided, the source should return data for that date.\n        - Date range would never exceed the `data_group_period` specified in the source config.\n\n    Returns:\n        An iterable of Quote or OHLC objects or a Polars DataFrame or a Pandas DataFrame.\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/models/#niveshpy.models.Source.get_source_config","title":"<code>get_source_config()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Get source configuration.</p> Source code in <code>niveshpy/models/sources.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef get_source_config(cls) -&gt; SourceConfig:\n    \"\"\"Get source configuration.\"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/models/#niveshpy.models.Source.get_source_info","title":"<code>get_source_info()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Get source information.</p> Source code in <code>niveshpy/models/sources.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef get_source_info(cls) -&gt; SourceInfo:\n    \"\"\"Get source information.\"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/models/#niveshpy.models.Source.get_source_key","title":"<code>get_source_key()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Get a unique key for this source.</p> Source code in <code>niveshpy/models/sources.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef get_source_key(cls) -&gt; str:\n    \"\"\"Get a unique key for this source.\"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/models/#niveshpy.models.Source.get_tickers","title":"<code>get_tickers()</code>  <code>abstractmethod</code>","text":"<p>Get the list of tickers.</p> Source code in <code>niveshpy/models/sources.py</code> <pre><code>@abc.abstractmethod\ndef get_tickers(self) -&gt; TickersIterable:\n    \"\"\"Get the list of tickers.\"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/models/#niveshpy.models.SourceConfig","title":"<code>SourceConfig</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Class to hold source configuration.</p>"},{"location":"reference/models/#niveshpy.models.SourceConfig.data_group_period","title":"<code>data_group_period = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The time period for which data can be grouped at source.</p> <p>This is used to limit the amount of calls made to the source. For example, if the source can return data for 1 month at a time, this should be set to 30 days.</p> <p>If this value is None, the data will not be grouped.</p> <p>This value will be passed to <code>polars.DataFrame.group_by_dynamic</code> to group the data by the specified time period.</p> <p>Default is None.</p>"},{"location":"reference/models/#niveshpy.models.SourceConfig.data_refresh_interval","title":"<code>data_refresh_interval = timedelta(days=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The time interval at which the source can be checked for new data.</p> <p>Note that this only applies to new data. Historical data, once fetched, will not be fetched again.</p> <p>This frequency will be ticker-specific unless the source uses the <code>ALL_TICKERS</code> strategy, in which case it will be source-specific.</p>"},{"location":"reference/models/#niveshpy.models.SourceConfig.source_strategy","title":"<code>source_strategy = SourceStrategy.DEFAULT</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The strategy to use for the source. Multiple strategies can be combined using bitwise OR. This is used to determine how to fetch and store data from the source.</p>"},{"location":"reference/models/#niveshpy.models.SourceConfig.ticker_refresh_interval","title":"<code>ticker_refresh_interval = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The time interval at which the source can be checked for new tickers.</p> <p>If this value is None, the source will not be checked for new tickers. Default is None.</p>"},{"location":"reference/models/#niveshpy.models.SourceInfo","title":"<code>SourceInfo</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Class to hold source information.</p>"},{"location":"reference/models/#niveshpy.models.SourceInfo.version","title":"<code>version</code>  <code>instance-attribute</code>","text":"<p>This will later add support for source migrations.</p>"},{"location":"reference/models/#niveshpy.models.SourceStrategy","title":"<code>SourceStrategy</code>","text":"<p>               Bases: <code>Flag</code></p> <p>Enum for source strategies.</p> <p>This enum defines the different strategies for data sources. Strategies can be combined using bitwise OR. These help in determining how to fetch and store data from the source. For example, if the source only supports fetching data for all tickers at a time, NiveshPy will store the data and use them in the future automatically.</p>"},{"location":"reference/models/#niveshpy.models.SourceStrategy.ALL_TICKERS","title":"<code>ALL_TICKERS = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The source fetches data for all tickers at once. Used for sources that do not support fetching data only for a list of provided tickers.</p>"},{"location":"reference/models/#niveshpy.models.SourceStrategy.DEFAULT","title":"<code>DEFAULT = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use this when the source does not require any special strategy.</p> <p>Default strategy: - The source only fetches data for the provided tickers (or all tickers if none are provided). - The source returns OHLC data.</p>"},{"location":"reference/models/#niveshpy.models.SourceStrategy.SINGLE_QUOTE","title":"<code>SINGLE_QUOTE = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The source returns a single quote for the provided ticker. Used for sources that do not support fetching OHLC data.</p>"},{"location":"reference/models/#niveshpy.models.Ticker","title":"<code>Ticker</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Class to hold ticker information.</p>"},{"location":"reference/models/#niveshpy.models.Ticker.get_polars_schema","title":"<code>get_polars_schema()</code>  <code>classmethod</code>","text":"<p>Get the Polars schema for the Ticker class.</p> Source code in <code>niveshpy/models/base.py</code> <pre><code>@classmethod\ndef get_polars_schema(cls) -&gt; pl.Schema:\n    \"\"\"Get the Polars schema for the Ticker class.\"\"\"\n    return pl.Schema(\n        {\n            \"symbol\": pl.String(),\n            \"name\": pl.String(),\n            \"isin\": pl.String(),\n        }\n    )\n</code></pre>"},{"location":"reference/niveshpy/","title":"NiveshPy","text":""},{"location":"reference/niveshpy/#niveshpy.Nivesh","title":"<code>niveshpy.Nivesh()</code>","text":"<p>This is the base class for NiveshPy.</p> <p>Initialize the Nivesh class.</p> Source code in <code>niveshpy/main.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the Nivesh class.\"\"\"\n    logger.debug(\"Initializing Nivesh\")\n    local_plugins = _import_local_plugins()\n    self.plugins: list[Plugin] = []\n    for plugin in local_plugins:\n        logger.debug(f\"Loaded plugin: {plugin.get_info()}\")\n        self.plugins.append(plugin)\n    logger.debug(f\"Loaded {len(self.plugins)} plugins\")\n    logger.debug(\"Nivesh initialized\")\n</code></pre>"},{"location":"reference/niveshpy/#niveshpy.Nivesh.get_quotes","title":"<code>get_quotes(*tickers, start_date=None, end_date=None, format=ReturnFormat.DICT, ohlc=True, resample=None)</code>","text":"<pre><code>get_quotes(*tickers: str, start_date: date = ..., end_date: date = ..., format: Literal[ReturnFormat.DICT] = ...) -&gt; dict[str, list]\n</code></pre><pre><code>get_quotes(*tickers: str, start_date: date = ..., end_date: date = ..., format: Literal[ReturnFormat.PL_DATAFRAME] = ...) -&gt; pl.DataFrame\n</code></pre><pre><code>get_quotes(*tickers: str, start_date: date = ..., end_date: date = ..., format: Literal[ReturnFormat.PL_LAZYFRAME] = ...) -&gt; pl.LazyFrame\n</code></pre><pre><code>get_quotes(*tickers: str, start_date: date = ..., end_date: date = ..., format: Literal[ReturnFormat.PD_DATAFRAME] = ...) -&gt; pd.DataFrame\n</code></pre><pre><code>get_quotes(*tickers: str, start_date: date = ..., end_date: date = ..., format: Literal[ReturnFormat.CSV, ReturnFormat.JSON] = ...) -&gt; str\n</code></pre> <p>Get the quotes for the specified tickers.</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>str | Tuple[str, str]</code> <p>The tickers to get quotes for.</p> <p>This can be a single symbol, a list of symbols, or a list of tuples containing the symbol and the source key. If source key is not specified, the pre-existing tickers are checked first. If not found, all out-dated sources are checked.</p> <code>()</code> <code>start_date</code> <code>date | None</code> <p>The start date for the quotes (inclusive). If None, defaults to today.</p> <code>None</code> <code>end_date</code> <code>date | None</code> <p>The end date for the quotes (inclusive). If None, defaults to today. The end date must be greater than or equal to the start date.</p> <code>None</code> <code>format</code> <code>ReturnFormat</code> <p>The format of the returned tickers. Defaults to ReturnFormat.DICT. See [niveshpy.models.helpers.ReturnFormat] for available formats.</p> <code>DICT</code> <code>ohlc</code> <code>bool</code> <p>If True, return OHLC data. If False, return single quotes.</p> <code>True</code> <code>resample</code> <code>timedelta | str | None</code> <p>The resampling period. If specified, the quotes will be resampled to the specified period. This can be a polars-compatible string (e.g. \"1d\", \"1w\", \"1mo\") or a timedelta object.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NiveshPyOutputType</code> <code>NiveshPyOutputType</code> <p>The quotes in the specified format.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the end date is before the start date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nivesh = Nivesh()\n&gt;&gt;&gt; quotes = nivesh.get_quotes(\"500209\", \"500210\", (\"500211\", \"amfi\"))\n</code></pre> Source code in <code>niveshpy/main.py</code> <pre><code>def get_quotes(\n    self,\n    *tickers: str | tuple[str, str],\n    start_date: date | None = None,\n    end_date: date | None = None,\n    format: ReturnFormat | str = ReturnFormat.DICT,\n    ohlc: bool = True,\n    resample: timedelta | str | None = None,\n) -&gt; NiveshPyOutputType:\n    \"\"\"Get the quotes for the specified tickers.\n\n    Args:\n        tickers (str | Tuple[str, str]): The tickers to get quotes for.\n\n            This can be a single symbol, a list of symbols, or a list of tuples\n            containing the symbol and the source key.\n            If source key is not specified, the pre-existing tickers are checked first.\n            If not found, all out-dated sources are checked.\n\n        start_date (date | None): The start date for the quotes (inclusive). If None, defaults to today.\n\n        end_date (date | None): The end date for the quotes (inclusive). If None, defaults to today.\n            The end date must be greater than or equal to the start date.\n\n        format (ReturnFormat): The format of the returned tickers.\n            Defaults to ReturnFormat.DICT. See [niveshpy.models.helpers.ReturnFormat] for available formats.\n\n        ohlc (bool): If True, return OHLC data. If False, return single quotes.\n\n        resample (timedelta | str | None): The resampling period.\n            If specified, the quotes will be resampled to the specified period.\n            This can be a polars-compatible string (e.g. \"1d\", \"1w\", \"1mo\") or a timedelta object.\n\n    Returns:\n        NiveshPyOutputType: The quotes in the specified format.\n\n    Raises:\n        ValueError: If the end date is before the start date.\n\n    Examples:\n        &gt;&gt;&gt; nivesh = Nivesh()\n        &gt;&gt;&gt; quotes = nivesh.get_quotes(\"500209\", \"500210\", (\"500211\", \"amfi\"))\n    \"\"\"\n    schema = OHLC.get_polars_schema() if ohlc else Quote.get_polars_schema()\n\n    if start_date and end_date and start_date &gt; end_date:\n        raise ValueError(\"Start date must be before end date\")\n\n    df_requested_tickers = (\n        self._handle_tickers(*tickers) if len(tickers) &gt; 0 else None\n    )\n    if df_requested_tickers is None:\n        logger.warning(\n            \"No tickers requested. \"\n            \"This will return quotes for all available tickers \"\n            \"from all sources. This might take a long time.\"\n        )\n\n        df_requested_tickers = self.get_tickers(format=ReturnFormat.PL_DATAFRAME)\n    elif df_requested_tickers.height == 0:\n        logger.warning(\"No tickers found matching the requested symbols.\")\n        return format_output(\n            schema.to_frame().with_columns(\n                source_key=pl.lit(None).cast(pl.String())\n            ),\n            format,\n        )\n\n    sources = self._get_sources(\n        source_keys=df_requested_tickers.select(\"source_key\")\n        .unique()\n        .to_series()\n        .to_list()\n    )\n\n    quotes = [\n        schema.to_frame(eager=True).with_columns(\n            pl.lit(None).cast(pl.String()).alias(\"source_key\")\n        )\n    ]\n\n    with ThreadPoolExecutor() as executor:\n        futures = {\n            executor.submit(\n                self._get_quotes,\n                df_requested_tickers.filter(\n                    pl.col(\"source_key\") == pl.lit(source.get_source_key())\n                )\n                .select(\"symbol\")\n                .to_series()\n                .to_list(),\n                source,\n                start_date,\n                end_date,\n            ): source\n            for source in sources\n        }\n\n        for future in futures:\n            source = futures[future]\n            try:\n                q = future.result()\n            except Exception:\n                logger.exception(\n                    f\"Error getting quotes from {source.get_source_key()}\"\n                )\n            else:\n                if (\n                    ohlc\n                    and SourceStrategy.SINGLE_QUOTE\n                    in source.get_source_config().source_strategy\n                ):\n                    # If the source returns a single quote, we need to convert it to OHLC\n                    # by duplicating the quote for open, high, low, and close\n                    q = q.select(\n                        pl.col(\"symbol\").alias(\"symbol\"),\n                        pl.col(\"date\").alias(\"date\"),\n                        pl.col(\"price\").alias(\"open\"),\n                        pl.col(\"price\").alias(\"high\"),\n                        pl.col(\"price\").alias(\"low\"),\n                        pl.col(\"price\").alias(\"close\"),\n                        pl.lit(source.get_source_key()).alias(\"source_key\"),\n                    )\n                elif (\n                    not ohlc\n                    and SourceStrategy.SINGLE_QUOTE\n                    not in source.get_source_config().source_strategy\n                ):\n                    # If the source returns OHLC data, we need to convert it to a single quote\n                    # by taking only the close price\n                    q = q.select(\n                        pl.col(\"symbol\").alias(\"symbol\"),\n                        pl.col(\"date\").alias(\"date\"),\n                        pl.col(\"close\").alias(\"price\"),\n                        pl.lit(source.get_source_key()).alias(\"source_key\"),\n                    )\n\n                quotes.append(q)\n                if logger.isEnabledFor(logging.DEBUG):\n                    logger.debug(f\"Quotes from source {source.get_source_key()}:\")\n                    logger.debug(q)\n\n    df_final_quotes = pl.concat(quotes)\n\n    if resample:\n        if ohlc:\n            df_final_quotes = df_final_quotes.group_by_dynamic(\n                \"date\",\n                every=resample,\n                group_by=[\"symbol\", \"source_key\"],\n            ).agg(\n                pl.col(\"open\").first().alias(\"open\"),\n                pl.col(\"high\").max().alias(\"high\"),\n                pl.col(\"low\").min().alias(\"low\"),\n                pl.col(\"close\").last().alias(\"close\"),\n            )\n        else:\n            df_final_quotes = df_final_quotes.group_by_dynamic(\n                \"date\",\n                every=resample,\n                group_by=[\"symbol\", \"source_key\"],\n            ).agg(\n                pl.col(\"price\")\n                .cast(pl.Float32())\n                .mean()\n                .cast(pl.Decimal(scale=4))\n                .alias(\"price\"),\n            )\n\n    return format_output(df_final_quotes, format)\n</code></pre>"},{"location":"reference/niveshpy/#niveshpy.Nivesh.get_sources","title":"<code>get_sources(source_keys=None)</code>","text":"<p>Get the list of sources from all plugins.</p> <p>Parameters:</p> Name Type Description Default <code>source_keys</code> <code>List[str] | None</code> <p>The source keys to filter by. Defaults to None. The source key is the key used to identify the source of the tickers. If source_keys is specified, only the sources from the specified keys are returned. For example, to filter by source key, you can use: source_key = [\"amfi\"] This will return only the sources from the AMFI source. If source_key is None, all sources from all plugins are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[SourceInfo]</code> <p>Iterable[SourceInfo]: An iterable of SourceInfo objects.</p> Source code in <code>niveshpy/main.py</code> <pre><code>def get_sources(self, source_keys: list[str] | None = None) -&gt; Iterable[SourceInfo]:\n    \"\"\"Get the list of sources from all plugins.\n\n    Args:\n        source_keys (List[str] | None): The source keys to filter by.\n            Defaults to None.\n            The source key is the key used to identify the source of the tickers.\n            If source_keys is specified, only the sources from the specified keys\n            are returned.\n            For example, to filter by source key, you can use:\n            source_key = [\"amfi\"]\n            This will return only the sources from the AMFI source.\n            If source_key is None, all sources from all plugins are returned.\n\n    Returns:\n        Iterable[SourceInfo]: An iterable of SourceInfo objects.\n    \"\"\"\n    sources = self._get_sources(source_keys)\n    return map(lambda source: source.get_source_info(), sources)\n</code></pre>"},{"location":"reference/niveshpy/#niveshpy.Nivesh.get_tickers","title":"<code>get_tickers(filters=None, source_keys=None, format=ReturnFormat.DICT)</code>","text":"<pre><code>get_tickers(filters: dict[str, list[str]] | None = None, source_keys: list[str] | None = None, format: Literal[ReturnFormat.DICT] = ...) -&gt; dict[str, list]\n</code></pre><pre><code>get_tickers(filters: dict[str, list[str]] | None = None, source_keys: list[str] | None = None, format: Literal[ReturnFormat.PL_DATAFRAME] = ...) -&gt; pl.DataFrame\n</code></pre><pre><code>get_tickers(filters: dict[str, list[str]] | None = None, source_keys: list[str] | None = None, format: Literal[ReturnFormat.PL_LAZYFRAME] = ...) -&gt; pl.LazyFrame\n</code></pre><pre><code>get_tickers(filters: dict[str, list[str]] | None = None, source_keys: list[str] | None = None, format: Literal[ReturnFormat.PD_DATAFRAME] = ...) -&gt; pd.DataFrame\n</code></pre><pre><code>get_tickers(filters: dict[str, list[str]] | None = None, source_keys: list[str] | None = None, format: Literal[ReturnFormat.JSON, ReturnFormat.CSV] = ...) -&gt; str\n</code></pre> <p>Get the list of tickers from all plugins.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>Dict[str, List[str]] | None</code> <p>Filters to apply to the tickers. Defaults to None. See [niveshpy.utils.filter_tickers] for available filters.</p> <code>None</code> <code>source_keys</code> <code>List[str] | None</code> <p>The source keys to filter by. Defaults to None. If source_keys is specified, only the tickers from the specified sources are returned. If source_key is None, all tickers from all sources are returned.</p> <code>None</code> <code>format</code> <code>ReturnFormat</code> <p>The format of the returned tickers. Defaults to ReturnFormat.DICT. See [niveshpy.models.helpers.ReturnFormat] for available formats.</p> <code>DICT</code> <p>Returns:</p> Name Type Description <code>NiveshPyOutputType</code> <code>NiveshPyOutputType</code> <p>The list of tickers in the specified format.</p> <code>NiveshPyOutputType</code> <p>The returned data has the following columns: - symbol: The ticker symbol. - name: The name of the ticker. - isin: The ISIN of the ticker. - source_key: The source key of the ticker. - last_updated: The last updated date of the source.</p> Source code in <code>niveshpy/main.py</code> <pre><code>def get_tickers(\n    self,\n    filters: dict[str, list[str]] | None = None,\n    source_keys: list[str] | None = None,\n    format: ReturnFormat | str = ReturnFormat.DICT,\n) -&gt; NiveshPyOutputType:\n    \"\"\"Get the list of tickers from all plugins.\n\n    Args:\n        filters (Dict[str, List[str]] | None): Filters to apply to the tickers.\n            Defaults to None.\n            See [niveshpy.utils.filter_tickers] for available filters.\n\n        source_keys (List[str] | None): The source keys to filter by.\n            Defaults to None. If source_keys is specified, only the tickers\n            from the specified sources are returned.\n            If source_key is None, all tickers from all sources are returned.\n\n        format (ReturnFormat): The format of the returned tickers.\n            Defaults to ReturnFormat.DICT. See [niveshpy.models.helpers.ReturnFormat] for available formats.\n\n    Returns:\n        NiveshPyOutputType: The list of tickers in the specified format.\n        The returned data has the following columns:\n            - symbol: The ticker symbol.\n            - name: The name of the ticker.\n            - isin: The ISIN of the ticker.\n            - source_key: The source key of the ticker.\n            - last_updated: The last updated date of the source.\n    \"\"\"\n    df_tickers = (\n        Ticker.get_polars_schema()\n        .to_frame(eager=False)\n        .with_columns(\n            pl.lit(None).cast(pl.String()).alias(\"source_key\"),\n        )\n    )\n    pre_loaded_sources: dict[str, datetime] = {}\n    try:\n        logger.debug(\"Getting locally saved tickers\")\n        df_tickers_pre = load_tickers()\n        logger.debug(\"Loaded locally saved tickers\")\n        df_sources = (\n            df_tickers_pre.group_by(\"source_key\")\n            .agg(pl.min(\"last_updated\").alias(\"last_updated\"))\n            .collect()\n        )\n        for row in df_sources.iter_rows(named=True):\n            source_key = row[\"source_key\"]\n            last_updated = row[\"last_updated\"]\n            pre_loaded_sources[source_key] = last_updated\n    except FileNotFoundError:\n        logger.debug(\"No locally saved tickers found\")\n        df_tickers_pre = df_tickers.clone().with_columns(\n            pl.lit(None).cast(pl.Datetime()).alias(\"last_updated\"),\n        )\n\n    logger.debug(\"Getting tickers from all plugins\")\n    all_tickers = [df_tickers]\n    for source in self._get_sources(source_keys):\n        # This will run for all sources matching the source_keys (if applicable)\n        key = source.get_source_key()\n        refresh_interval = source.get_source_config().ticker_refresh_interval\n        if key in pre_loaded_sources and (\n            refresh_interval is None\n            or (datetime.now() - pre_loaded_sources[key]) &lt; refresh_interval\n        ):\n            logger.debug(f\"Skipping source {key} as it is up to date\")\n        else:\n            logger.debug(f\"Getting tickers from source {key}\")\n            all_tickers.append(\n                handle_input(\n                    source.get_tickers(), Ticker.get_polars_schema()\n                ).with_columns(pl.lit(key).alias(\"source_key\"))\n            )\n\n    logger.debug(\"Combining tickers from all plugins\")\n    df_tickers = pl.concat(all_tickers, how=\"vertical_relaxed\").select(\n        pl.col(\"symbol\").cast(pl.String()),\n        pl.col(\"name\").cast(pl.String()),\n        pl.col(\"isin\").cast(pl.String()),\n        pl.col(\"source_key\").cast(pl.String()),\n        pl.lit(datetime.now()).alias(\"last_updated\"),\n    )\n\n    df_tickers_collected = df_tickers.collect()\n    if df_tickers_collected.height &gt; 0:\n        logger.debug(\"Combining tickers with locally saved tickers\")\n        df_tickers_collected = df_tickers_pre.collect().update(\n            df_tickers_collected,\n            on=[\"source_key\", \"symbol\"],\n            how=\"full\",\n        )\n\n        logger.debug(\"Saving all tickers to local file\")\n        save_tickers(df_tickers_collected)\n    else:\n        logger.debug(\"No new tickers found\")\n        df_tickers_collected = df_tickers_pre.collect()\n\n    logger.debug(\"Applying filters to tickers\")\n    df_tickers_collected = apply_filters(df_tickers_collected, source_keys, filters)\n    return format_output(df_tickers_collected, format)\n</code></pre>"},{"location":"reference/niveshpy/#niveshpy.Nivesh.register_plugin","title":"<code>register_plugin(plugin)</code>","text":"<p>Register a custom plugin.</p> Source code in <code>niveshpy/main.py</code> <pre><code>def register_plugin(self, plugin: Plugin):\n    \"\"\"Register a custom plugin.\"\"\"\n    if isinstance(plugin, Plugin):\n        self.plugins.append(plugin)\n        logger.info(f\"Registered plugin: {plugin.get_info()}\")\n    else:\n        raise TypeError(\"Plugin must be an instance of Plugin class\")\n</code></pre>"},{"location":"reference/plugins/","title":"Plugins","text":"<p>The following built-in plugins are available:</p> <ul> <li>AMFI</li> </ul>"},{"location":"reference/plugins/amfi/","title":"AMFI","text":"<p>A built-in plugin for NiveshPy that provides AMFI as a source.</p>"},{"location":"reference/plugins/amfi/#amfi.AMFIPlugin","title":"<code>AMFIPlugin()</code>","text":"<p>               Bases: <code>Plugin</code></p> <p>AMFI Plugin for NiveshPy.</p> <p>Initialize the AMFI plugin.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the AMFI plugin.\"\"\"\n    super().__init__()\n    self.sources = [AMFISource()]\n</code></pre>"},{"location":"reference/plugins/amfi/#amfi.AMFIPlugin.get_info","title":"<code>get_info()</code>  <code>classmethod</code>","text":"<p>Return plugin information.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>@classmethod\ndef get_info(cls) -&gt; PluginInfo:\n    \"\"\"Return plugin information.\"\"\"\n    return cls.plugin_info\n</code></pre>"},{"location":"reference/plugins/amfi/#amfi.AMFIPlugin.get_sources","title":"<code>get_sources()</code>","text":"<p>Return a list of sources for the plugin.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>def get_sources(self):\n    \"\"\"Return a list of sources for the plugin.\"\"\"\n    # Here you would return a list of sources that the plugin provides.\n    # For Examples:\n    return self.sources\n</code></pre>"},{"location":"reference/plugins/amfi/#amfi.AMFISource","title":"<code>AMFISource()</code>","text":"<p>               Bases: <code>Source</code></p> <p>AMFI Source for NiveshPy.</p> <p>Initialize the AMFI source.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the AMFI source.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/plugins/amfi/#amfi.AMFISource.get_quotes","title":"<code>get_quotes(*_, start_date=None, end_date=None)</code>","text":"<p>Get quotes for the all tickers.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>def get_quotes(self, *_, start_date=None, end_date=None):\n    \"\"\"Get quotes for the all tickers.\"\"\"\n    url = self.LATEST_URL\n    if start_date and end_date:\n        url = self.HISTORICAL_URL.format(\n            frm_dt=start_date.strftime(\"%d-%b-%Y\"),\n            to_dt=end_date.strftime(\"%d-%b-%Y\"),\n        )\n    elif start_date:\n        url = self.HISTORICAL_URL.format(\n            frm_dt=start_date.strftime(\"%d-%b-%Y\"),\n            to_dt=start_date.strftime(\"%d-%b-%Y\"),\n        )\n    elif end_date:\n        url = self.HISTORICAL_URL.format(\n            frm_dt=end_date.strftime(\"%d-%b-%Y\"),\n            to_dt=end_date.strftime(\"%d-%b-%Y\"),\n        )\n\n    df = pl.read_csv(\n        url,\n        separator=\";\",\n        null_values=[\"N.A.\", \"-\"],\n        infer_schema=False,\n    )\n    df = df.drop_nulls(subset=[\"Date\"])\n    df = df.select(\n        pl.col(\"Scheme Code\").alias(\"symbol\").cast(pl.String()),\n        pl.col(\"Date\").alias(\"date\").str.strptime(pl.Date, \"%d-%b-%Y\"),\n        pl.col(\"Net Asset Value\").alias(\"price\").cast(pl.Decimal(None, 4)),\n    )\n    return df\n</code></pre>"},{"location":"reference/plugins/amfi/#amfi.AMFISource.get_source_config","title":"<code>get_source_config()</code>  <code>classmethod</code>","text":"<p>Return source configuration.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>@classmethod\ndef get_source_config(cls):\n    \"\"\"Return source configuration.\"\"\"\n    return SourceConfig(\n        ticker_refresh_interval=timedelta(days=7),\n        data_refresh_interval=timedelta(days=1),\n        data_group_period=timedelta(days=30),\n        source_strategy=SourceStrategy.ALL_TICKERS | SourceStrategy.SINGLE_QUOTE,\n    )\n</code></pre>"},{"location":"reference/plugins/amfi/#amfi.AMFISource.get_source_info","title":"<code>get_source_info()</code>  <code>classmethod</code>","text":"<p>Return source information.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>@classmethod\ndef get_source_info(cls):\n    \"\"\"Return source information.\"\"\"\n    return SourceInfo(\n        name=\"Mutual Fund India\",\n        description=\"Data source for all Indian mutual funds, sourced from AMFI.\",\n        key=AMFISource.get_source_key(),\n        version=1,\n    )\n</code></pre>"},{"location":"reference/plugins/amfi/#amfi.AMFISource.get_source_key","title":"<code>get_source_key()</code>  <code>classmethod</code>","text":"<p>Return the source key.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>@classmethod\ndef get_source_key(cls):\n    \"\"\"Return the source key.\"\"\"\n    return \"amfi\"\n</code></pre>"},{"location":"reference/plugins/amfi/#amfi.AMFISource.get_tickers","title":"<code>get_tickers()</code>","text":"<p>Get the list of tickers.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>def get_tickers(self):\n    \"\"\"Get the list of tickers.\"\"\"\n    try:\n        df = pl.scan_csv(\n            self.LATEST_URL,\n            separator=\";\",\n            null_values=[\"N.A.\", \"-\"],\n            infer_schema=False,\n        )\n        df = df.drop_nulls(subset=[\"Date\"])\n        return df.select(\n            pl.col(\"Scheme Code\").alias(\"symbol\"),\n            pl.col(\"Scheme Name\").alias(\"name\"),\n            pl.coalesce(pl.col(\"^ISIN .*$\")).alias(\"isin\"),\n        )\n    except Exception:\n        logger.exception(\"Failed to get tickers\")\n        return []\n</code></pre>"},{"location":"reference/plugins/amfi/#amfi.register_plugin","title":"<code>register_plugin()</code>","text":"<p>Register the plugin with NiveshPy.</p> Source code in <code>niveshpy/plugins/amfi.py</code> <pre><code>def register_plugin() -&gt; AMFIPlugin:\n    \"\"\"Register the plugin with NiveshPy.\"\"\"\n    return AMFIPlugin()\n</code></pre>"}]}